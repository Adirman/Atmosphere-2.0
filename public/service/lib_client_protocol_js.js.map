{"version":3,"file":"lib_client_protocol_js.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;;AAEO;AACP;;AAEA,gBAAgB,qBAAqB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA,gBAAgB,qBAAqB;AACrC;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA","sources":["webpack://dynamic-interception-proxy/./lib/client/protocol.js"],"sourcesContent":["const valid_chars = \"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~\";\nconst reserved_chars = \"%\";\n\nexport function validProtocol(protocol){\n\tprotocol = protocol.toString();\n\n\tfor(let i = 0; i < protocol.length; i++){\n\t\tconst char = protocol[i];\n\n\t\tif(!valid_chars.includes(char)){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nexport function encodeProtocol(protocol){\n\tprotocol = protocol.toString();\n\n\tlet result = '';\n\t\n\tfor(let i = 0; i < protocol.length; i++){\n\t\tconst char = protocol[i];\n\n\t\tif(valid_chars.includes(char) && !reserved_chars.includes(char)){\n\t\t\tresult += char;\n\t\t}else{\n\t\t\tconst code = char.charCodeAt();\n\t\t\tresult += '%' + code.toString(16).padStart(2, 0);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function decodeProtocol(protocol){\n\tif(typeof protocol != 'string')throw new TypeError('protocol must be a string');\n\n\tlet result = '';\n\t\n\tfor(let i = 0; i < protocol.length; i++){\n\t\tconst char = protocol[i];\n\t\t\n\t\tif(char == '%'){\n\t\t\tconst code = parseInt(protocol.slice(i + 1, i + 3), 16);\n\t\t\tconst decoded = String.fromCharCode(code);\n\t\t\t\n\t\t\tresult += decoded;\n\t\t\ti += 2;\n\t\t}else{\n\t\t\tresult += char;\n\t\t}\n\t}\n\n\treturn result;\n}"],"names":[],"sourceRoot":""}